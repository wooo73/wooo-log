#### Promise의 특징과 async/await 특징

---

-   **Promise**

    -   Promise는 JavaScript에서 비동기 작업의 결과값을 나타내는 객체
    -   대기, 이행, 거부의 3가지 상태를 가진다.

        -   대기(Pending): 초기 상태, 이행 또는 거부되지 않은 상태
        -   이행(Fulfilled): 연산이 성공적으로 완료
        -   거부(Rejected): 연산이 실패

    -   Promise 체이닝
        -   여러 비동기 작업을 순차적으로 수행하기 위해 Promise를 연결하는 방법.
        -   then()을 사용하여 여러 비동기 작업을 순차적으로 처리 가능하다.
        -   catch()로 에러 처리가 진행된다.

-   **async/await 특징**

    -   Promise를 기반으로 직관적인 비동기 처리 문법으로 동기 코드처럼 사용되어 가독성이 좋다.
    -   async함수는 항상 Promise를 반환하며 await는 Promise가 처리될 때까지 현재 함수의 실행을 일시 중지한다.
    -   try-catch를 사용하여 에러 처리가 진행된다.

#### 콜 스택과 태스크 큐

---

-   콜스택

    -   자바스크립트 엔진이 함수 호출을 추적하는 데이터 구조이다.
    -   LIFO구조로 가장 마지막에 추가된 함수가 가장 먼저 처리
    -   함수가 호출되면 해당 함수의 실행 컨텍스트가 스택에 추가되고, 함수 실행이 완료되면 스택에서 제거됨.
    -   싱글 스레드로 한번에 하나의 작업만 처리된다.

```js
function first() {
    second()
}

function second() {
    third()
}

function third() {
    console.log("third")
}
first()
```

1. first() 호출 → 스택에 first 추가
2. second() 호출 → 스택에 second 추가
3. third() 호출 → 스택에 third 추가
4. third() 실행 완료 → 스택에서 third 제거
5. second() 실행 완료 → 스택에서 second 제거
6. first() 실행 완료 → 스택에서 first 제거

-   태스트 큐

    -   비동기 작업의 콜백 함수가 대기하는 큐
        -   타이머, 이벤트 핸들러, Promise 등 비동기 작업 완료 후 실행할 콜백 함수들이 저장됨
    -   FIFO구조로 먼저 들어온 작업이 먼저 처리
    -   매크로태스크큐: setTimeout, setInterval, setImmediate, I/O 작업등의 콜백
    -   마이크로태스크 큐: Promise, process.nextTick, queueMicrotask 등의 콜백

마이크로태스크가 매크로태스크 보다 우선순위가 더 높아 먼저 처리된다.

```js
console.log("시작")

setTimeout(() => {
    console.log("타임아웃 콜백")
}, 0)

Promise.resolve().then(() => {
    console.log("프로미스 콜백")
})

console.log("종료") // 시작, 종료, 프로미스 콜백, 타임아웃 콜백, 종료 순 출력
```

#### 클로저

---

클로저는 함수가 자신이 생성될 당시의 환경(변수, 스코프 체인)을 기억하고 있다가, 나중에 호출될 때 그 환경에 접근할 수 있는 특성이다.

주요 특징

-   자신이 생성된 시점의 스코프에 있는 변수에 접근 가능.
-   함수 실행이 끝나면 지역 변수는 소멸하지만, 클로저를 통해 해당 변수들의 생명주기를 연장 가능.
-   클로저를 통해 private 변수처럼 외부에서 직접 접근할 수 없는 변수 생성 가능

-   가비지 컬렉션
    -   더 이상 사용되지 않는 메모리를 자동으로 해제하는 프로세스
        -   참조되지 않는 객체를 메모리에서 해제함.
    -   동작 원리
        -   루트 객체를 기준으로 참조 그래프 생성
        -   참조 그래프를 탐색하여, 더 이상 참조되지 않는 객체를 찾고, 메모리에서 해제함.

클로저와 가비지 컬렉션

-   클로저는 외부 함수의 변수를 참조하기 때문에, 해당 변수들이 가비지 컬렉션의 대상이 되지 않아 메모리 누수가 발생할 수 있음.
-   불필요한 참조를 제거하는 것이 중요
    -   클로저 내부 더 이상 사용되지 않는 변수를 null 설정

#### 변수의 생성 과정과 호이스팅

---

-   변수의 생성 과정

    1. 선언 단계: 변수를 실행 컨텍스트의 변수 객체 등록.
    2. 초기화 단계: 변수 객체에 등록된 변수를 위한 공간을 메모리에 확보, 변수는 undefined로 초기화.
    3. 할당 단계: undefined로 초기화된 변수에 실제 값을 할당.

-   호이스팅

    JavaScript 엔진이 코드를 실행하기 전 변수와 함수 선언을 해당 스코프의 최상단으로 끌어올리는 것처럼 동작하는 특성.

-   var로 선언한 변수는 선언과 초기화가 함께 호이스팅된다.

```js
var name // 선언 및 undefined로 초기화 (호이스팅)
console.log(name) // undefined
name = "홍길동" // 할당
```

-   let, const로 선언한 변수도 호이스팅되지만, 선언만 호이스팅되고 초기화는 호이스팅되지 않는다. 이로 인해 일시적 사각지대(Temporal Dead Zone, TDZ) 발생

```js
// name 선언이 호이스팅됨 (초기화는 되지 않음)
// 여기서부터 TDZ 시작
console.log(name) // TDZ 내에서 접근하려고 하므로 ReferenceError
let name // 이 지점에서 초기화 (TDZ 종료)
name = "홍길동" // 할당
```

#### 화살표 함수

---

기존의 함수 표현식보다 더 짧은 구문을 제공하며 몇가지 특징이 있다.

-   화살표 함수가 정의된 시점의 상위 스코프의 this를 사용.
-   자체 arguments 객체를 가지고 있지 않아 상위 스코프 arguments를 참조해야함.
-   화살표 함수는 생성자 함수로 사용할 수 없다. prototype 속성이 없고, new 연산자로 호출하면 TypeError가 발생함.

#### 깊은 복사와 얕은 복사의 차이

---

-   얕은 복사

    -   얕은 복사는 객체의 최상위 속성만 복사하는 방식
    -   객체 내부에 중첩된 객체나 배열은 참조 값만 복사되어, 원본과 복사본이 동일한 내부 객체를 참조하게 됨.

        -   원본과 복사본이 같은 객체를 바라보게 되어 원본의 중첩 객체가 변경되면 복사본도 영향을 받음.

    -   구현 방법

        -   Object.assign()
        -   Spread Operator([...])
        -   slice()

-   깊은 복사

    -   깊은 복사는 객체의 모든 수준의 속성을 완전히 새로운 메모리에 복사하는 방식.
    -   원본과 복사본은 완전히 독립적인 객체가 됨.
        -   원본과 복사본은 완전히 독립적이어서 서로 영향을 주지않음.
    -   구현 방법

        -   JSON
        -   재귀 함수
        -   lodash 라이브러리의 cloneDeep

#### 고차 함수

---

-   함수를 매개변수로 받는 함수
-   함수를 반환하는 함수
-   함수를 값(first-class citizen)으로 취급하는 JavaScript의 특성을 활용함.

-   사용예시
    -   map()
        -   각 요소에 함수를 적용하고 새 배열 반환
    -   filter()
        -   조건을 만족하는 요소만 필터링
    -   reduce()
        -   배열을 단일 값으로 축소
