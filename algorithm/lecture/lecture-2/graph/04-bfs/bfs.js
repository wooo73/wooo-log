// 승원이는 당근을 좋아해서 당근마킷에 엔지니어로 취업했다.
// 당근을 매우좋아하기 때문에 차도 당근차를 샀다.
// 이 당근차는 한칸 움직일 때마다 당근을 내뿜으면서 간다.
// 즉, "한칸" 움직일 때 "당근한개"가 소모된다는 것이다.
// 승원이는 오늘도 아침 9시에 일어나 당근마킷으로 출근하고자 한다.
// 승원이는 최단거리로 당근마킷으로 향한다고 할 때 당근몇개를 소모해야 당근마킷에 갈 수 있는지 알아보자.
// 이 때 승원이는 육지로만 갈 수 있으며 바다로는 못간다.
// 맵의 1은 육지며 0은 바다를 가리킨다. 승원이는 상하좌우로만 갈 수 있다.

// 입력
// 맵의 세로길이 N과 가로길이 M 이 주어지고 이어서 N * M의 맵이 주어진다.
// 그 다음 줄에 승원이의 위치(y, x)와 당근마킷의 위치(y, x)가 주어진다.
// 이 때 승원이의 시작위치(y, x)에서 "당근한개"가 이미 소모된 상태로 본다.

// 출력
// 당근을 몇개 소모해야 하는지 출력하라.

// 범위
// 1 <= N <= 100
// 1 <= M <= 100

// 5 5
// 0 0
// 4 4
// 1 0 1 0 1
// 1 1 1 0 1
// 0 0 1 1 1
// 0 0 1 1 1
// 0 0 1 1 1

const dy = [-1, 0, 1, 0];
const dx = [0, 1, 0, -1];

function main() {
  // 입력값 설정
  const n = 5;
  const m = 5;
  const sy = 0; // 시작점 y
  const sx = 0; // 시작점 x
  const ey = 4; // 끝점 y
  const ex = 4; // 끝점 x

  // 맵 (1: 갈 수 있음, 0: 바다/장애물)
  const a = [
    [1, 0, 1, 0, 1],
    [1, 1, 1, 0, 1],
    [0, 0, 1, 1, 1],
    [0, 0, 1, 1, 1],
    [0, 0, 1, 1, 1],
  ];

  // visited 배열 초기화
  const visited = Array.from({ length: n }, () => Array(m).fill(0));

  // BFS 시작
  const q = [];
  visited[sy][sx] = 1; // 시작점 방문 표시
  q.push([sy, sx]);

  while (q.length) {
    const [y, x] = q.shift(); // 큐에서 꺼내기

    // 4방향 탐색
    for (let i = 0; i < 4; i++) {
      const ny = y + dy[i];
      const nx = x + dx[i];

      // 범위 밖이거나 바다(0)면 건너뛰기
      if (ny < 0 || ny >= n || nx < 0 || nx >= m || a[ny][nx] === 0) continue;

      // 이미 방문했으면 건너뛰기
      if (visited[ny][nx]) continue;

      // 거리 = 현재 거리 + 1
      visited[ny][nx] = visited[y][x] + 1;
      q.push([ny, nx]);
    }
  }

  // 최단거리 출력
  console.log("최단거리:", visited[ey][ex]);
  console.log();

  // 전체 맵의 거리 출력 (디버깅용)
  console.log("거리 맵:");
  for (let i = 0; i < n; i++) {
    console.log(visited[i].join(" "));
  }
}

main();
